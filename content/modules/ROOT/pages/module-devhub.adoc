= Gen AI into Parasol - 70 minutes
:imagesdir: ../assets/images
:sectnums:

++++
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3HTRSDJ3M4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3HTRSDJ3M4');
</script>
++++

== Goals of this lab

*Parasol* is standardizing on an *internal developer portal (IDP)* for its developers to use to build, deploy, and manage cloud native applications, including those with AI capabilities. In this exercise, you will learn how to harness the power of the Parasol internal developer portal to streamline and enhance your development workflow for AI apps. This exercise will guide you through creating a new application using a software template, observing the automatic CI/CD processes powered by Tekton and Argo, and using your web-based IDE, Red Hat Dev Spaces. You'll create a new branch to develop and add an AI feature, such as an email generator. After merging your pull request, you'll monitor the deployment process via OpenShift GitOps in the Red Hat Dev Hub dashboard. Finally, you'll verify the functionality of your new application by accessing its frontend page. This hands-on experience will empower you to efficiently utilize the Parasol developer portal for seamless application development and deployment.

include::module-devhub-preq.adoc[]

== Add a new generative AI feature

https://developers.redhat.com/products/openshift-dev-spaces/overview[Red Hat OpenShift Dev Spaces^] is a cloud-based development environment built on top of Kubernetes and containers. It offers a streamlined and secure way for developers to code, build, and test applications directly within the OpenShift ecosystem. You'll use the Dev Spaces to develop a new Generative AI feature (e.g.,`email generator`).

=== Create a new Gen AI email service

You'll create a few Java classes to process 

==== Create Java records beans

Create a new Java file, `Email.java` in the `src/main/java/org/parasol/model` directory to carry email data in a concise and immutable way. Copy the following code and paste it into the Email.java file.

[.console-input]
[source,java,subs="+attributes,macros+"]
----
package org.parasol.model;

public record Email(String text) { }
----

[.console-input]
[source,java,subs="+attributes,macros+"]
----
package org.parasol.model;

public record EmailResponse(String subject, String message) { }
----

Create a new Jakarta REST resource

[.console-input]
[source,java,subs="+attributes,macros+"]
----
package org.parasol.resources;

import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

import org.parasol.ai.EmailService;
import org.parasol.model.Email;
import org.parasol.model.EmailResponse;

@Produces(MediaType.APPLICATION_JSON)
@Path("/api/email")
public class EmailResource {

    @Inject
    EmailService bot;

    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    public EmailResponse getresponse(Email claimEmail) {
        return bot.chat(claimEmail.text());
    }
}

----

[.console-input]
[source,java,subs="+attributes,macros+"]
----
package org.parasol.resources;

import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

import org.parasol.ai.EmailService;
import org.parasol.model.Email;
import org.parasol.model.EmailResponse;

@Produces(MediaType.APPLICATION_JSON)
@Path("/api/email")
public class EmailResource {

    @Inject
    EmailService bot;

    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    public EmailResponse getresponse(Email claimEmail) {
        return bot.chat(claimEmail.text());
    }
}
----


[.console-input]
[source,javascript,subs="+attributes,macros+"]
----

----


[.console-input]
[source,properties,subs="+attributes,macros+"]
----

----


== Create a new pull request (PR)

Make a new branch to create a new pull request (PR) to add a new AI feature (e.g., a new AI service, e.g. search) to the existing application - potentially using code assistant extension (PR)

== Merge the PR

Merge the PR which will trigger a new pipeline

== Monitor the new deployment

Monitor if the new deployment rolls out by the OpenShift GitOps in the Dev Hub web console.

== Verify the new app’s functionality

Verify the new app’s functionality by accessing the frontend page (Parasol)

== Conclusion

We hope you have enjoyed this module!

Here is a quick summary of what we have learned:

- TBD
- TBD
- TBD